package org.gbif.geocode.ws.layers;

import org.gbif.common.shaded.com.google.common.base.Strings;
import org.gbif.geocode.api.cache.AbstractBitmapCachedLayer;
import org.gbif.geocode.api.model.Location;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Stopwatch;

import au.org.ala.layers.intersect.SimpleShapeFile;

/**
 * A shapefile-backed layer with a bitmap cache.
 *
 * Assumes shapefiles have three columns (id, title, isoCode), as generated by database/import.sh.
 */
public abstract class AbstractShapefileLayer extends AbstractBitmapCachedLayer {
  private Logger LOG = LoggerFactory.getLogger(getClass());
  final SimpleShapeFile simpleShapeFile;
  private final Stopwatch intersectionSw = Stopwatch.createUnstarted();
  private long queries = 0;

  String[] idColumnLookup;
  String[] titleColumnLookup;
  String[] isoCodeColumnLookup;
  int[] idColumnIndex;
  int[] titleColumnIndex;
  int[] isoCodeColumnIndex;

  public AbstractShapefileLayer(InputStream bitmap) {
    this(bitmap, 1);
  }

  AbstractShapefileLayer(InputStream bitmap, int maxLocations) {
    super(bitmap, maxLocations);
    this.simpleShapeFile = null;
  }

  AbstractShapefileLayer(SimpleShapeFile simpleShapeFile, InputStream bitmap) {
    this(simpleShapeFile, bitmap, 1);
  }

  AbstractShapefileLayer(SimpleShapeFile simpleShapeFile, InputStream bitmap, int maxLocations) {
    super(bitmap, maxLocations);
    this.simpleShapeFile = simpleShapeFile;
    idColumnLookup = simpleShapeFile.getColumnLookup(0);
    titleColumnLookup = simpleShapeFile.getColumnLookup(1);
    isoCodeColumnLookup = simpleShapeFile.getColumnLookup(2);
    idColumnIndex = simpleShapeFile.getColumnIdxs("ID");
    titleColumnIndex = simpleShapeFile.getColumnIdxs("NAME");
    isoCodeColumnIndex = simpleShapeFile.getColumnIdxs("ISOCOUNTRY");
  }

  public List<Location> convertResultToLocation(List<ImmutablePair<Integer, Double>> countryValues) {
    List<Location> locations = new ArrayList<>();

    for (Pair<Integer, Double> countryValue : countryValues) {
      String id = idColumnLookup[idColumnIndex[countryValue.getLeft()]];
      String title = titleColumnLookup[titleColumnIndex[countryValue.getLeft()]];
      String isoCode = isoCodeColumnLookup[isoCodeColumnIndex[countryValue.getLeft()]];

      boolean additionalHit = false;
      for (Location e : locations) {
        // We may get multiple results for a MultiPolygon; return only the nearest hit.
        if (e.getId().equals(id)) {
          additionalHit = true;
          if (e.getDistance() > countryValue.getRight()) {
            // Replace
            e.setDistance(countryValue.getRight());
          } else {
            break;
          }
        }
      }
      if (!additionalHit) {
        Location l = new Location();
        l.setType(name());
        l.setSource(source());
        l.setId(id);
        l.setTitle(title);
        l.setIsoCountryCode2Digit(Strings.emptyToNull(isoCode));
        l.setDistance(countryValue.getRight());
        locations.add(l);
      }
    }

    return locations;
  }

  public List<Location> lookup(double latitude, double longitude, double uncertainty) {
    intersectionSw.start();

    List<ImmutablePair<Integer, Double>> intersections = simpleShapeFile.intersectInt(longitude, latitude, uncertainty);
    List<Location> locations = convertResultToLocation(intersections);

    queries++;
    intersectionSw.stop();
    return locations;
  }

  public void reportLookup(long q) {
    long elapsed = intersectionSw.elapsed(TimeUnit.SECONDS);
    if (elapsed > 0) {
      LOG.info("[At {}] {} did {} shapefile queries ({} per second).", q, name(), queries, queries / elapsed);
    }
  }
}
